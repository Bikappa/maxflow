[{"E:\\workspace\\nightfun\\src\\components\\flow\\FlowNode.tsx":"1","E:\\workspace\\nightfun\\src\\components\\FlowNetworkEditor\\FlowNetworkEditor.tsx":"2","E:\\workspace\\nightfun\\src\\geometry\\index.tsx":"3","E:\\workspace\\nightfun\\src\\utils\\index.tsx":"4","E:\\workspace\\nightfun\\src\\components\\flow\\FlowArc.tsx":"5","E:\\workspace\\nightfun\\src\\maxflow\\FordFulkerson.tsx":"6","E:\\workspace\\nightfun\\src\\index.tsx":"7","E:\\workspace\\nightfun\\src\\App.tsx":"8","E:\\workspace\\nightfun\\src\\components\\FlowNetworkEditor\\SmartButton.tsx":"9"},{"size":1341,"mtime":1609671756000,"results":"10","hashOfConfig":"11"},{"size":9215,"mtime":1609713810000,"results":"12","hashOfConfig":"11"},{"size":816,"mtime":1609506528000,"results":"13","hashOfConfig":"11"},{"size":136,"mtime":1607195950000,"results":"14","hashOfConfig":"11"},{"size":1471,"mtime":1609713860000,"results":"15","hashOfConfig":"11"},{"size":2168,"mtime":1609523274000,"results":"16","hashOfConfig":"11"},{"size":352,"mtime":1607197046000,"results":"17","hashOfConfig":"11"},{"size":168,"mtime":1609534240000,"results":"18","hashOfConfig":"11"},{"size":413,"mtime":1609712526000,"results":"19","hashOfConfig":"11"},{"filePath":"20","messages":"21","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1um9xdh",{"filePath":"22","messages":"23","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"24"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"E:\\workspace\\nightfun\\src\\components\\flow\\FlowNode.tsx",[],"E:\\workspace\\nightfun\\src\\components\\FlowNetworkEditor\\FlowNetworkEditor.tsx",["39","40","41"],"import { AppBar, ButtonGroup, makeStyles, Toolbar } from \"@material-ui/core\";\n\nimport { memo, useCallback, useMemo, useReducer, useState } from \"react\";\nimport { createUseStyles } from \"react-jss\";\nimport { Point } from \"../../geometry\";\nimport { fordFulkerson } from \"../../maxflow\";\nimport { FlowArc, FlowNetworkNode } from \"../flow\";\nimport { NodeId, NumericLabeledArcs } from \"../types\";\nimport { SmartButton } from \"./SmartButton\";\nimport FlagIcon from '@material-ui/icons/Flag';\nimport PlayArrowIcon from \"@material-ui/icons/PlayArrow\";\nimport InputIcon from '@material-ui/icons/Input';\nimport DeleteIcon from '@material-ui/icons/Delete';\n\nconst useStyles = createUseStyles({\n  canvas: {\n    width: '100%',\n    height: '100vh',\n  }\n})\n\nconst useMUIStyles = makeStyles((theme) => ({\n  root: {\n    '& > *': {\n      margin: theme.spacing(1),\n    },\n  },\n  grow: {\n    flexGrow: 1,\n  },\n}));\n\nclass Node<T>{\n  private id: NodeId\n  public value: T\n\n  constructor(id: NodeId, value: T) {\n    this.id = id;\n    this.value = value\n  }\n}\n\ntype NodeData = {\n  id: string,\n  position: Point,\n}\n\nfunction absoluteCoordinate(normalizedCoordinate: number, length: number) {\n  return (length + normalizedCoordinate * length) / 2\n}\nfunction normalizedCoordinate(absoluteCoordinate: number, length: number) {\n  return (absoluteCoordinate * 2 - length) / length\n}\n\nfunction absolutePosition(normalizedPosition: Point) {\n  return {\n    x: absoluteCoordinate(normalizedPosition.x, window.innerWidth),\n    y: absoluteCoordinate(normalizedPosition.y, window.innerHeight),\n  }\n}\n\nfunction relativePosition(absolutePosition: Point) {\n  return {\n    x: normalizedCoordinate(absolutePosition.x, window.innerWidth),\n    y: normalizedCoordinate(absolutePosition.y, window.innerHeight),\n  }\n}\n\nenum EDITOR_ACTIONS {\n  ADD_NODE,\n  REMOVE_NODE,\n  MOVE_NODE,\n  ADD_ARC,\n  SET_SOURCE,\n  SET_SINK,\n  SELECT_NODE\n}\n\ntype Action =\n  { type: EDITOR_ACTIONS.ADD_NODE, payload: NodeData }\n  | { type: EDITOR_ACTIONS.REMOVE_NODE, payload: NodeId }\n  | { type: EDITOR_ACTIONS.MOVE_NODE, payload: { id: NodeId, position: Point } }\n  | { type: EDITOR_ACTIONS.ADD_ARC, payload: { from: NodeId, to: NodeId, capacity: number } }\n  | { type: EDITOR_ACTIONS.SET_SOURCE, payload: NodeId | undefined }\n  | { type: EDITOR_ACTIONS.SET_SINK, payload: NodeId | undefined }\n  | { type: EDITOR_ACTIONS.SELECT_NODE, payload: NodeId }\n\n\ntype EditorState = {\n  nodes: { [id: string]: NodeData }\n  arcs: NumericLabeledArcs\n  flow: NumericLabeledArcs\n  source?: NodeId\n  sink?: NodeId\n  selectedNode?: NodeId\n}\n\nfunction reducer(state: EditorState, action: Action): EditorState {\n  switch (action.type) {\n    case EDITOR_ACTIONS.ADD_NODE:\n      return {\n        ...state,\n        nodes: {\n          ...state.nodes,\n          [action.payload.id]: action.payload\n        }\n      }\n    case EDITOR_ACTIONS.REMOVE_NODE:\n      const { [action.payload]: deleted, ...nodes } = state.nodes\n      const { [action.payload]: arcsFromRemovedNode, ...arcs } = state.arcs\n\n      //remove the ingoing arcs to the node\n      for (const tos of Object.values(arcs)) {\n        delete tos[action.payload]\n      }\n      return {\n        ...state,\n        arcs,\n        nodes,\n        selectedNode: action.payload !== state.selectedNode ? state.selectedNode : undefined,\n        source: action.payload !== state.source ? state.source : undefined,\n        sink: action.payload !== state.sink ? state.source : undefined,\n      }\n    case EDITOR_ACTIONS.ADD_ARC:\n      return {\n        ...state,\n        selectedNode: undefined,\n        arcs: {\n          ...state.arcs,\n          [action.payload.from]: {\n            ...state.arcs[action.payload.from],\n            [action.payload.to]: action.payload.capacity\n          }\n        },\n      }\n    case EDITOR_ACTIONS.MOVE_NODE:\n      return {\n        ...state,\n        nodes: {\n          ...state.nodes,\n          [action.payload.id]: {\n            ...state.nodes[action.payload.id],\n            position: action.payload.position\n          }\n        }\n      }\n    case EDITOR_ACTIONS.SET_SOURCE:\n      return {\n        ...state,\n        selectedNode: undefined,\n        source: action.payload\n      }\n    case EDITOR_ACTIONS.SET_SINK:\n      return {\n        ...state,\n        selectedNode: undefined,\n        sink: action.payload\n      }\n    case EDITOR_ACTIONS.SELECT_NODE:\n      return {\n        ...state,\n        selectedNode: action.payload !== state.selectedNode ? action.payload : undefined\n      }\n    default:\n      return state\n\n  }\n}\n\n\nexport function FlowNetworkEditor() {\n\n  const [flow, setFlow] = useState<NumericLabeledArcs>({})\n  const [defaultArcCapacity] = useState(10)\n\n  const [state, dispatch] = useReducer(reducer, {\n    nodes: {},\n    arcs: {},\n    flow: {},\n  })\n\n  const { sink, source, selectedNode } = state\n  const dragHandler = useCallback((id, event) => {\n\n    event.preventDefault()\n    const position = relativePosition({ x: event.clientX, y: event.clientY })\n\n    dispatch({\n      type: EDITOR_ACTIONS.MOVE_NODE,\n      payload: {\n        id,\n        position\n      }\n    })\n\n  }, [])\n\n  const canvasClickHandler = useCallback((e: React.MouseEvent) => {\n    dispatch({\n      type: EDITOR_ACTIONS.ADD_NODE,\n      payload: {\n        id: '' + Date.now(),\n        position: relativePosition({ x: e.clientX, y: e.clientY })\n      }\n    })\n  }, [])\n\n\n  const nodeClickHandler = useMemo(() => {\n    return (id: NodeId) => {\n\n      if (!selectedNode || id === selectedNode) {\n        dispatch({\n          type: EDITOR_ACTIONS.SELECT_NODE,\n          payload: id\n        })\n        return\n      }\n\n      //we add the new arc\n      if (!state.arcs[selectedNode]?.[id] && !state.arcs[id]?.[selectedNode]) {\n        dispatch({\n          type: EDITOR_ACTIONS.ADD_ARC,\n          payload: {\n            from: selectedNode,\n            to: id,\n            capacity: Math.round(8 * Math.random()) + 2\n          }\n        })\n      }\n    }\n  }, [selectedNode, state.arcs])\n\n  const runClickHandler = useMemo(() => {\n    return source && sink ? () => {\n      new Promise<NumericLabeledArcs>((resolve) => {\n        const flow = fordFulkerson(source, sink, state.arcs)\n        resolve(flow)\n      }).then(setFlow)\n    } : undefined\n  },\n    [state.arcs, source, sink])\n\n  const deleteClickHandler = useMemo(() => {\n    return selectedNode ? () => {\n      //remove the node\n      dispatch({\n        type: EDITOR_ACTIONS.REMOVE_NODE,\n        payload: selectedNode,\n      })\n\n    } : undefined\n  },\n    [selectedNode])\n\n  const sourceMarkClickHandler = useMemo(() => {\n    return selectedNode && selectedNode !== sink ? () => {\n      dispatch({\n        type: EDITOR_ACTIONS.SET_SOURCE,\n        payload: selectedNode !== source ? selectedNode : undefined,\n      })\n    } : undefined\n  },\n    [selectedNode, sink, source]\n  )\n\n  const sinkMarkClickHandler = useMemo(() => {\n    return selectedNode && selectedNode !== source ? () => {\n      dispatch({\n        type: EDITOR_ACTIONS.SET_SINK,\n        payload: selectedNode !== sink ? selectedNode : undefined,\n      })\n    } : undefined\n  },\n    [selectedNode, sink, source]\n  )\n\n\n  const classes = useStyles()\n  const muiClasses = useMUIStyles()\n\n  const Bar = useMemo(() => <AppBar position=\"fixed\">\n    <Toolbar className={muiClasses.root}>\n      <div  className={muiClasses.grow}/>\n      <ButtonGroup variant='contained' >\n        <SmartButton onClick={sourceMarkClickHandler} startIcon={<InputIcon />}>{selectedNode === source ? 'Unm' : 'M'}ark as source</SmartButton>\n        <SmartButton onClick={sinkMarkClickHandler} startIcon={<FlagIcon />}>{selectedNode === sink ? 'Unm' : 'M'}ark as sink</SmartButton>\n        <SmartButton onClick={deleteClickHandler} startIcon={<DeleteIcon />}>Delete</SmartButton>\n      </ButtonGroup>\n      <SmartButton onClick={runClickHandler} color='primary' variant='contained' startIcon={<PlayArrowIcon />}>Compute</SmartButton>\n    </Toolbar>\n  </AppBar>,\n    [sourceMarkClickHandler, sinkMarkClickHandler, runClickHandler, deleteClickHandler, source, sink, selectedNode, muiClasses])\n\n\n  return <>\n    {Bar}\n    <div onClick={canvasClickHandler} className={classes.canvas}>\n      {\n        Object.values(state.nodes).map(node => {\n          const pos = absolutePosition(node.position)\n          return <FlowNetworkNode\n            key={node.id}\n            onDrag={dragHandler}\n            onClick={() => nodeClickHandler(node.id)}\n            {...node}\n            positionX={pos.x}\n            positionY={pos.y}\n            bgColor={node.id === selectedNode ? 'red' : undefined}\n            label={sink === node.id ? <FlagIcon /> : (source === node.id ? <InputIcon /> : undefined)}\n          />\n        })\n      }\n      {\n        Object.keys(state.arcs).map(from => Object.keys(state.arcs[from]).map(to => {\n          const start = absolutePosition(state.nodes[from].position)\n          const end = absolutePosition(state.nodes[to].position)\n          return <FlowArc\n            key={from + '-' + to}\n            flow={flow[from]?.[to] || 0}\n            capacity={state.arcs[from][to]}\n            startX={start.x}\n            startY={start.y}\n            endX={end.x}\n            endY={end.y}\n          />\n        })).flat()\n      }\n    </div>\n  </>\n\n}","E:\\workspace\\nightfun\\src\\geometry\\index.tsx",[],"E:\\workspace\\nightfun\\src\\utils\\index.tsx",[],"E:\\workspace\\nightfun\\src\\components\\flow\\FlowArc.tsx",[],"E:\\workspace\\nightfun\\src\\maxflow\\FordFulkerson.tsx",[],"E:\\workspace\\nightfun\\src\\index.tsx",[],"E:\\workspace\\nightfun\\src\\App.tsx",[],"E:\\workspace\\nightfun\\src\\components\\FlowNetworkEditor\\SmartButton.tsx",[],{"ruleId":"42","severity":1,"message":"43","line":3,"column":10,"nodeType":"44","messageId":"45","endLine":3,"endColumn":14},{"ruleId":"42","severity":1,"message":"46","line":33,"column":7,"nodeType":"44","messageId":"45","endLine":33,"endColumn":11},{"ruleId":"42","severity":1,"message":"47","line":174,"column":10,"nodeType":"44","messageId":"45","endLine":174,"endColumn":28},"@typescript-eslint/no-unused-vars","'memo' is defined but never used.","Identifier","unusedVar","'Node' is defined but never used.","'defaultArcCapacity' is assigned a value but never used."]